####BASIC CONTEXT#######
Hi kiro, we are creating a class registration app.
This whole app is divided into 3 major parts
1. Front End
2. Back End
3. Database.

For each part you will follow strict conditions to create the application.

Each part of the work will be broadly divided into the following steps:
1. Requirements --> This will tell you the technology required to create this specific parts
2. Functionality --> This will explain in bullet points what does each function should do.
3. Output --> After each function there will be a heading called output, where the expected output will be explained.
4. Design --> This will help you understand the structure of the application.
Your task is to:
1. Take the requirements, check whether they are present in the system, if not, install them.
2. After the requirements are installed, using the mcp server get context from context7 for each of these tools.
3. Next step is to go through the functionalities, create steering documents for each part of the project.
4. Use context7 to create these functionalities.
5. Create steering documents.
6. Output of the functions should match the expected output.
7. For every task that you complete, the final subtask should be testing if the tests work or not?
8. After every test case create a README.md file with namingformat -> taskName-issue.md 
9. Put whatever test cases failed or passed and how it was troubleshooted in there, reference line 711 of this prompt.txt
10. To test backend, use asynchronous test cases, or use curl command on the routes to test routes.
11. Use nodemon to continuously work and update the server.
12. Task 1 should be creation of envSetter.py (ref: line 659) and server.js (basic app file) so that it can stay running in background and you can test over it.

The initial structure of the project is divided into 2 parts:
/
|
|──FrontEnd
|──BackEnd
|──Database

####DEVELOPMENT####
######################################

#####DATABASE#####
######REQUIREMENTS######
1. Node.js
2. aws-sdk
3. npm 
4. nodemon 

######FUNCTIONALITIES and OUTPUT######

FUNCTIONALITY 1: CREATE DATABASE
 - These function should start when the server is started.
Function 1: createDatabase
    - Create 3 databases. "studentUserDB", "classDB" and "classRegistrationDB"
   
    - Check if these databases already exists first, if they do, return.
    - The following step are to be followed only if the databases do not exists.
        -- Create a node.js code using aws-sdk to create the 3 databases.
        -- UserDB should have the following attributes:
            -- userID (primary Key) --> number
            -- username -> string
            -- fullName -> string
            -- email --> string
            -- encrypted password --> encrypted password
        -- ClassDB should have the following attributes: 
            -- classId --> string 
            -- className --> string
            -- credits --> number
            -- Description --> string
                --Dummy Data:
                {
                    classID: "IFT 593"  --> every class Id will have either IFT, CSE, CCE, or EEE  followed by random 3 digit number.
                    className: "Advanced Computer Networks" --> Generate some dummy class name
                    credits: 4 -> credits can only be 3 or 4.
                    Description: "this is a description of this class, create a small 3 sentence description
                }
        -- ClassRegDB should have the following attributes:
            -- classId -> string -> foreign key from ClassDB
            -- userID -> number -> foreign key from UserDB
            -- className --> string -> foreign key from ClassDB
            -- registerationState --> enrolled / dropped.



FUNCTIONALITY 2: EXTRACT DATA
Function 1: userExistsInDB(username or email) return true or false.
    - take in username or email, checks "studentUserDB" where any of the two inputs are present.
        - if the user exists return true
        - if the user does not exists return false.

Function 2: dispEnrolledClass (userId) return array of class
    -  takes in userId, get all the rows with matching userID and status as enrolled.
    -  extract classId and class name pair, return the array of classID className pair.

Function 3: getAllclasses() returns an array of class.
    - just takes all the classId, className pair from ClassDB and returns.

Function 3: dispAvailableClass(userId) returns array of class
    - invokes dispEnrolledClass(userId)
    - invokes getAllclasses()
    - compares the two array obtained, returns a unique array (remove the subset array obtained from dispEnrolledClass)

Function 4: dispDroppedClass(userId) returns array of class
    - conditions  
        userId: userId,
        registationStatus: "dropped".

FUNCTIONALITY 3: PUSH DATA IN Database
Function 1: pushUserData()
    - takes in username, fullname, email, password.
    - encrypts the password with bcrypt.
    - checks if email or user exists, returns false.
    - otherwise, generates a 10 digit userId and push data 
    for example:
        user = {
            userId: 1232802807,
            fullName: Vikalp Parashar
            userName: Warlord
            email: vparash1@asu.edu 
            password: $2$jsadi12998./dahauwed/ah2
        }

Function 2: addDummyDataToClassDB()
    - Only to run when createDatabase() is run. So when in createDatabase() creates classDB after that this function should be invoked from the inside.
    - Generate a minimum of 5 to maximum of 10 classes.
    - For classId
        - It should have have either IFT, CSE, CCE, or EEE  followed by random 3 digit number. For example: IFT 593, CSE 201, EEE 192
    - Credits 
        - Randomly pick either 3 or 4.
    - className
        - Generate a random name
    - Description
        - Generate a description based on the name.
    - Push the data into classDB

Function 3: pushRegistry()
    - takes in classId, userId, className and registerStatus
    - Checks if classId and userId exists.
    -pushes the data.

    Example:
        register ={
            classId: "IFT 402",
            userId: 1232802807,
            className: "Introduction to robotics".
            registerStatus: "enrolled"
        }

Function 4: updateRegistry()
    - to change the registerStatus if a student drops from class
    - change registerStatus: "dropped".
    - to change dropped back to enrolled if the student re-enrolls.

######DESIGN######

PROJECT STRUCTURE: 
/
|
|──FrontEnd
|──BackEnd
|──Database
    |
    |-ALL FILES HERE -> NO EXTRA DIRECTORY

WORKFLOW:
SERVER STARTS

    -> createDatabase() --> already exists, move on
                --> doesnt exists, create UserDB, classDB, classRegistrationDB
                                                    |
                                                    |--invoke addDummyDataToClassDB()
################################################################################

#####BACK-END#####
######REQUIREMENTS######
1.Express.js
2. npm
3. nodemon
4. dependencies from others

######FUNCTIONALITIES and OUTPUT######

FUNCTIONALITY 1: LOGIN, REGISTER & LOGOUT.
Function 1: registerStudentUser(req, res){
    - invokes userExistsInDB(username, email).
    - if exist, return 401. email or username already exists.
    - else
        - invoke pushUserData(), get the unique generated id.
        - generate JWT token using all of the data that we have in user through generateToken() --> this function will be in /──BackEnd/middlewares/auth.js
        example code:
            export const generateTokens = (req) => {

                const payload = {
                    userId: uniqueGenId,
                    username: req.body.username,
                    email: req.body.email
                };

                const accessToken = jwt.sign(payload, JWT_SECRET, { 
                    expiresIn: JWT_EXPIRES_IN,
                    issuer: 'school-app',
                    audience: 'school-app-users'
                });

                const refreshToken = jwt.sign(
                    { userId: user._id, type: 'refresh' }, 
                    JWT_SECRET, 
                    { 
                    expiresIn: JWT_REFRESH_EXPIRES_IN,
                    issuer: 'safe-app',
                    audience: 'safe-app-users'
                    }
                );

                return { accessToken, refreshToken };
                };
        - return 200. successful sign up and JWT token 
}
Function 2: loginStudentUser (req,res){
    - invoke userExistsInDB(username, email)
        -if exists, proceed. get the userId
        -else return return 404, user or email doesnt exists.
    - invoke compare =  comparePassword(userID, password)
        - invokes generateBcryptEncryptPass(password)
        - invokes getPasswordByUserId(userId)
        - compare
            - Matches, return true
            - return false
    - if compare == true,
        - invoke generateToken()
        - return 200, succesfully logged in
    - else 
        - return 400, credentials incorrect. 

}

Function 3: logoutStudentUser (req, res){
    - JWT token
        - blacklist it.
}

FUNCTIONALITY 2:CLASS INFORMATION RETRIEVAL
Function 1: displayAllAvaliableClasses (req, res){
    - invoke verify_token() -> to get the userId.
    - invoke dispAvailableClass(userId).
        if empty array, return all classes registered. 
        else send array with 200.

}
Function 2: getDroppedClasses (req,res){
    - invoke verify_token
    - invoke dispDroppedClass(userId);
        -If empty array, return -> no classes dropped yet.
        else return array.
     
}
Function 3: getEnrolledClasses (req, res){
    -invoke verify_token
    -invoke dispEnrolledClass(userId);
        -if empty array, return -> no classes enrolled
        else return array.
}

FUNCTIONALITY 3: CLASS REGISTRATION
Function 1: registerClass (req, res){
    -invoke verify_token() -> get userId
    - invoke dispEnrolledClass(userId){
        -if present, return 400, class already registered.
        else invoke dispDroppedClass(userId){
            - if present, invoke updateRegistry(classId,userId,status)
            - else invoke pushRegistry(userId,classId,className, status=enrolled).return 200 succesfully enrolled.
        }
    }
}
Function 2: De-register(req, res){
    - invoke verify_token()
    - invoke dispEnrolledClass(userID){
        -if absent, return 400, the course is either not registered or dropped.
        else, invoke updateRegistry(classId, userId, status=dropped)
    } 
}
FUNCTIONALITY 4: HELPER FUNCTIONS:
File 1:  auth.js 
    -> have all the functionalities to handle authentication and JWT.
File 2: logger.js
    -> logs request and response, in basics single line. Ex: GET /auth/login 10.10.23.12 8080 200 OK 
    -> color code it.
File 3: password.js
    -> handles functionalities for password encryption.

######DESIGN######
PROJECT STRUCTURE
/
|
|──FrontEnd
|──BackEnd
    |
    |--Controller --> contains the actual functions 
    |--Router   --> set routes for the api requests
    |--Middleware --> houses different middlewares like loggers, authHelpers, etc.
    |--Logs --> store logs.

|──Database

loginController.js -> handles functions related to login,logout, registeration.
classController.js -> handles functions related to class

loginRouter.js -> routes the request for login functionalities
classRouter.js -> routes the request for class related functionalities

API path for loginFunctionalities => /api/loginFunc/
API path for class => /api/classFunc.


################################################################################

#####FRONT-END#####
######REQUIREMENTS######
1. React
2. Next.js
3. HTML
4. CSS
5. npm
6. nodemon.

######FUNCTIONALITIES and OUTPUT######

FUNCTIONALITY 1: LOGIN REGISTRATION & LOGOUT

- Create three functions "userRegisterRequest", "userLoginRequest", "logout".
- userRegisterRequest:
-- will take Full name, email, username, and password from the user and send it backend using API. 
-- will receive a JWT token and store it.
- userLoginRequest:
-- can use either email or username for the login process, and they will take a password, send it over to the backend by API.
-- will receive a JWT token and store it.
- userLogout:
-- will remove and delete the jwt token and go to login page.
-- send the JWT token to blacklist.

OUTPUT 1: API
- Send input in a JSON format.
- Use fetch(), method POST.

OUTPUT 2: RESPONSE HANDLING
- Response will have JWT_Token=, save it on the browser.
- Depending on the status code, different responses are expected.
-- 200 -> Functionality executed successful. example: in the logout functionality, 200 will imply successful logout.
-- 404 -> The resource is not found. Example: if login receives 404, it implies the username or email is incorrect.
-- Handle other cases using common HTML logic.
 

FUNCTIONALITY 2: DISPLAY CLASSES

- Create a navigation panel on the left, with "available classes", "my classes" and "Dropped class" tab.
- Create a GET function "displayAllAvaliableClasses" to show all available classes to the logged-in user, when the user clicks on available classes tab.
- Create a GET function "displayEnrolledClasses" to show the classes enrolled by the logged-in user, when the user clicks on the my classes tab.
- Create a Get function "displayDroppedClasses" to show the classes dropped by the logged-in user, when the user clicks on the dropped classes.

OUTPUT 1: API
- Use fetch(), method GET.

OUTPUT: RESPONSE HANDLING
-- 200 implies successful function execution
-- 404 implies resource not found. In displayEnrolledClasses status 404 will be shown as no classes enrolled, please enroll! <--something like that
-- Handle other cases using common HTML logic.

FUNCTIONALITY 3: ENROLL AND UNENROLL IN CLASSES.
- Create an enroll button for each class in the "available classes" tab. 
- Create an un-enroll button for each class in the "my classes" tab.
- Create a re-enroll buttion for each class in the "Dropped classes" tab
- Create a POST function "enrollClass", to enroll the student to the selected class using onClick.
- Create a POST function "unenrollClass", to unenroll the student from the selected class using onClick.
- Use the POST function "enrollClass", in the Dropped classes re-enroll button, to again enroll the class.
OUTPUT: API
- Send ClassId as input in JSON format
- Use fetch(), method POST.

OUTPUT: RESPONSE HANDLING
-- 200 implies successful function execution. 
-- 404 implies resource not found.

FUNCTIONALITY 4: VERIFICATION.
- Create a function to check password Strength.
-- In SignUp page in the password field it take value everytime user types (keyboard stroke), and check against the password policy.
-- Password should be minimum of 10 characters, should have numbers, alphabets, special character, uppercase lowercases.

- Create a function to check whether a valid email is being entered or not.

OUTPUT: 
- Show if the password is strong,weak and medium
- Show if the password has followed the password policy
- Show if the email entered is a valid email.

######DESIGN######
PROJECT STRUCTURE:
/
|
|──FrontEnd
   |
   |--js
   |--CSS
   |--HTML

WORKFLOW:
Landing page -> login page --> Text fields ->Username or email 
                                           ->password
                           --> login button + Sign Up link.
                                    |            |
                                    |            |-- Sign Up page --> Text fields    -> Full name
                                    |                                                -> email
                                    |                                                -> username
                                    |                                                -> password
                                    |                                                -> Verify password
                                    |                            --> Sign Up button
                                    |                                   |
                                    |-----------------------------------|--> Available classes Tab 


FORMATTING AND DESIGNS.
- Use context7 to create a simple yet modern style webpage.
- Make sure the formatting is correct.
- Use this website as a reference https://www.arlo.co/course-registration-software?utm_source=google&utm_medium=cpc&utm_campaign=Arlo_Non_Brand_US_CA&utm_term=course%20registration%20system&gad_source=1&gad_campaignid=18459765791&gbraid=0AAAAADvJHlwtTTS3g08DvyHGiTIEPHgqN&gclid=Cj0KCQjw9obIBhCAARIsAGHm1mTEks_IFRLcC1S_6Hg5izUv2IXdXqn-iLz7geHcA_CPlnhLkAVcwXgaAvaPEALw_wcB


####TESTING ASPECTS#####
For testing first use context7 to get the context for these testing technology and then create a steering document for them
and then continue testing
Jest (v29.7.0) - Test runner & assertions
Supertest (v6.3.3) - HTTP API testing
React Testing Library (v13.4.0) - Component testing
                                    
####SECURITY ASPECTS####

Following are the guidelines for webApp security.

1. AUTHENTICATION & AUTHORIZATION SECURITY

    - Use bcrypt with a minimum salt rounds of 12 (recommended: 14)
    - Implement password hashing before database storage
    - Implement secure password comparison using
    `bcrypt.compare()`
    - Enforce password complexity requirements:
    - Minimum 12 characters (upgrade from current 10)
    - At least one uppercase letter
    - At least one lowercase letter
    - At least one number
    - At least one special character
    - No common passwords (implement password dictionary check)
    - Implement password reset functionality with secure tokens (time-limited, single-use)
    - Rate limit password reset requests to prevent abuse

2. JWT TOKEN SECURITY
    - Store `JWT_SECRET` in environment variables (`.env` file), NEVER hardcode
    - Use strong, randomly generated secrets (minimum 256 bits)
    - Implement short access token expiration (15-30 minutes)
    - Implement longer refresh token expiration (7-30 days)
    - Store refresh tokens securely (httpOnly cookies preferred over localStorage)
    - Implement token blacklisting for logout functionality (as already planned)
    - Validate token signature, expiration, issuer, and audience on every request
    - Implement token rotation on refresh
    - Use HTTPS only for token transmission
    - Never expose tokens in URL parameters or logs

3. SESSION MANAGEMENT 

    - Implement automatic session timeout after inactivity (30 minutes recommended)
    - Clear all authentication data on logout
    - Implement "Remember Me" functionality securely if needed
    - Detect and prevent concurrent sessions if required
    - Implement secure session invalidation on password change
    - DO NOT ALLOW PASSWORD TRIES FOR MORE THAN 5 times, start rate-limit or banning for incremental order of time.
    - Add two factor authentication
        - For MFA, take the email id of the user, match the emailId from db, if the email is present, proceed otherwise End
        - Generate a 6 digit random number, keep it hidden, when user inputs the number:
            -If it matches, allow login 
            -If it doesn't match
                - Allow 3 tries
                - Give option to send another code to their email.
                - Store the email address with risk levels or just prevent access until administrator doesn't allow.
    
4. DATA VALIDATION
    - Validate ALL user inputs on both client-side AND server-side
    - Implement schema validation using libraries (e.g., Joi, express-validator)
    - Validate email format using proper regex patterns
    - Validate username format (alphanumeric, length constraints)
    - Sanitize all inputs to prevent code injection
    - Implement strict type checking for all inputs
    - Validate file uploads (if implemented later) for type, size, and content
    - Never trust client-side validation alone

5. SQL/NoSQL INJECTION PREVENTION

    - Use parameterized queries or prepared statements for ALL database operations
    - Never concatenate user input directly into database queries
    - Use AWS SDK's built-in parameter binding
    - Implement input sanitization before database operations
    - Use ORM/ODM libraries with proper escaping mechanisms
    - Validate and sanitize `classId`,`userId` before using in queries

6. CROSS-SITE SCRIPTING (XSS) PREVENTION
- Sanitize all user-generated content before rendering
- Implement Content Security Policy (CSP) headers
- Escape HTML special characters in user inputs
- Use React's built-in XSS protection (avoid `dangerouslySetInnerHTML`)
- Validate and sanitize class descriptions and names
- Implement output encoding for all dynamic content

7. API SECURITY
    - Implement rate limiting on all endpoints (e.g., 100 requests per 15 minutes)
    - Add stricter rate limits on authentication endpoints (e.g., 5 login attempts per 15 minutes)
    - Implement CORS (Cross-Origin Resource Sharing) with specific allowed origins
    - Use HTTPS/TLS for all API communications (minimum TLS 1.2)
    - Implement API versioning for maintainability
    - Add request size limits to prevent DoS attacks
    - Implement request timeout limits
    - Use security headers (Helmet.js for Express):
        `X-Content-Type-Options: nosniff`
        `X-Frame-Options: DENY`
        `X-XSS-Protection: 1; mode=block`
        `Strict-Transport-Security`
        `Content-Security-Policy`

8. AUTHENTICATION MIDDLEWARE
    - Verify JWT token on EVERY protected route
    - Implement proper error handling without exposing sensitive information
    - Check token against blacklist on every request
    - Validate user permissions for each operation
    - Implement middleware execution order correctly
    - Log authentication failures for monitoring

9. ENDPOINT PROTECTION
    - Protect ALL class registration endpoints with authentication
    - Implement authorization checks (users can only modify their own registrations)
    - Validate `userId` from JWT matches the requested operation
    - Prevent enumeration attacks (don't reveal if user/email exists during login)
    - Implement CSRF protection for state-changing operations

10. DATABASE ACCESS CONTROL 

    - Use AWS IAM roles with least privilege principle
    - Create separate database users for different operations
    - Never use root/admin credentials in application code
    - Store database credentials in environment variables
    - Implement database connection encryption (SSL/TLS)
    - Use VPC security groups to restrict database access
    - Regularly rotate database credentials
    - Enable database audit logging

11. DATA PROTECTION

    - Encrypt sensitive data at rest (if storing additional PII later)
    - Implement database backups with encryption
    - Use AWS DynamoDB encryption features
    - Implement soft deletes instead of hard deletes for audit trails
    - Sanitize database error messages before sending to client
    - Prevent mass assignment vulnerabilities
    - Implement transaction management for data consistency

12.  QUERY PROTECTION

    - Validate foreign key relationships before operations
    - Implement existence checks before updates/deletes
    - Use batch operations securely
    - Limit query result sizes to prevent data leakage
    - Implement pagination for large datasets
    - Never expose internal database IDs directly if possible

13. CLIENT-SIDE SECURITY

    - Never store sensitive data in localStorage (use httpOnly cookies for tokens if possible)
    - If using localStorage for tokens, implement additional security measures
    - Implement proper token storage and retrieval
    - Clear sensitive data from memory after use
    - Validate all inputs before sending to backend
    - Implement proper error handling without exposing system details
    - Use environment variables for API endpoints
    - Implement secure routing (protect routes requiring authentication)
    - Prevent clickjacking with proper CSP headers

14. DEPENDENCY SECURITY

    - Regularly update all npm packages
    - Use`npm audit` to check for vulnerabilities
    - Implement `package-lock.json` or `yarn.lock`
    - Avoid using packages with known vulnerabilities
    - Review dependencies before adding to project
    - Use Dependabot or similar tools for automated updates

15. SECURITY LOGGING
    - Log ALL authentication attempts (success and failure)
    - Log ALL authorization failures
    - Log suspicious activities (multiple failed logins, unusual patterns)
    - Include timestamp, IP address, user identifier in logs
    - NEVER log sensitive data (passwords, tokens, PII)
    - Implement log rotation and secure storage
    - Use structured logging format (JSON)
    - Store logs in the `/BackEnd/Logs` directory as per design

16. MONITORING AND ALERTING
    - Monitor for brute force attacks
    - Implement alerts for suspicious activities
    - Track rate limit violations
    - Monitor for SQL injection attempts
    - Set up alerts for application errors
    - Implement health check endpoints (without exposing sensitive info)

17. SECURE ERROR HANDLING
    - Implement centralized error handling middleware
    - Never expose stack traces to clients
    - Return generic error messages to users
    - Log detailed errors server-side only
    - Use appropriate HTTP status codes
    - Avoid revealing system architecture in errors
    - Implement different error messages for development vs production

18. INFORMATION DISCLOSURE PREVENTION
    - Remove or disable server signature headers
    - Don't expose technology stack in responses
    - Avoid verbose error messages
    - Remove comments from production code
    - Don't expose database schema information
    - Sanitize all response data
    - Implement proper API documentation without exposing vulnerabilities

19. CODE SECURITY PRACTICES
    - Implement security code reviews
    - Use ESLint with security plugins
    - Follow OWASP Top 10 guidelines
    - Implement principle of least privilege throughout code
    - Avoid `eval()`and similar dangerous functions
    - Use strict mode in JavaScript
    - Implement proper access control checks
    - Comment security-critical code sections

20. 19. ENVIRONMENT CONFIGURATION
- Use
`
.env
` files for all sensitive configuration
- Add `
.env
` to
`
.gitignore
` (NEVER commit secrets)
- Use different credentials for development, testing, and production
- Implement environment variable validation on startup
- Document all required environment variables
**Example
```
JWT_SECRET=your-256-bit-secret-here
JWT_EXPIRES_IN=30m
JWT_REFRESH_EXPIRES_IN=7d
AWS_ACCESS_KEY_ID=your-key
AWS_SECRET_ACCESS_KEY=your-secret
AWS_REGION=us-east-1

NODE_ENV=development
PORT=3000

Ask user to run envSetter.py file to fill in these values, if not already present.
As they are critical to the application even working.

For example if a user runs: npm run dev and this file is not initialized, stop execution and 
prompt the user to run python3 envSetter.py 

envSetter.py is an basic interactive file that will take user input and create a .env file through that input.

21. TESTING & VALIDATION
    - Implement security testing in CI/CD pipeline
    - Test authentication and authorization flows
    - Perform input validation testing
    - Test rate limiting functionality
    - Implement automated security scanning
    - Conduct manual security reviews
    - Test error handling scenarios

Before deploying, verify:
- [ ] All passwords are hashed with bcrypt (salt rounds >= 12)
- [ ] JWT secrets are in environment variables
- [ ] All API endpoints have authentication/authorization
- [ ] Input validation implemented on both client and server
- [ ] Rate limiting configured on all endpoints
- [ ] HTTPS enforced for all communications
- [ ] Security headers configured (use Helmet.js)
- [ ] CORS properly configured
- [ ] Error messages don't expose sensitive information
- [ ] Logging implemented (without logging sensitive data)
- [ ] Database credentials secured in environment variables
- [ ] Token blacklisting working for logout
- [ ] SQL/NoSQL injection prevention implemented
- [ ] XSS prevention measures in place
- [ ] `.env` file added to `.gitignore`
- [ ] `npm audit` shows no high/critical vulnerabilities
- [ ] Password complexity requirements enforced (12+ chars)
- [ ] Session timeout implemented
- [ ] All user inputs sanitized and validated


**Remember:**
-
**Defense in Depth**: Implement security at every layer
-
**Least Privilege**: Grant minimum necessary permissions
-
**Fail Securely**: Default to denying access when errors occur
-
**Keep it Simple**: Complex security is hard to maintain
-
**Never Trust Input**: Always validate and sanitize
-
**Security by Design**: Build security in from the start, not as an afterthought



####ISSUES and RESOLUTIONS####

- Create a fix-summary folder.
- Whatever issues you face while creating the app, make a one sentence info about it
- Show troubleshooting methodology
- Give a one line prompt so that this issue can be remediated in the next iteration without 
you troubleshooting

    ###STUCTURE###
     1. Issues Faced:
     // Enter issue Faced
     2. Troubleshooting:
     // Enter everything you have tried in bullet points
     3. Improvement prompt
     // Generate a prompt that you can use in next iteration in the prompt.txt, that will stop this issue
     // and will also stop you from hallucinating.